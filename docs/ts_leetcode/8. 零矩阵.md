---
lang: zh-CN
title: 8. 零矩阵
sidebarDepth: 0
---

### 题目描述

编写一种算法，若 `M × N` 矩阵中某个元素为0，则将其所在的行与列清零。

要求：只使用 `O(1)` 的额外空间占用。


### 示例

```
// 示例一
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
// 示例二
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```


### 思路

分成两步：  
第一次遍历标记某行、某列是否有0，第二次遍历清理整个矩阵。

利用 矩阵的第一行、第一列 作为一种哈希表。  
第一次遍历除第一行和第一列的内容，如果位置`[i][j]`为0，把`[i][0]`和`[0][j]`标记为0。  
第二次遍历除第一行和第一列的内容，如果`[i][0]`或`[0][j]`有一个为0，把`[i][j]`置为0。

第一列最后处理，只需要一个额外的变量标记是否有 0 即可。

时间复杂度：O(m \* n)  
空间复杂度：O(1)


### 代码

```ts
function setZeroes(matrix: number[][]): void {
  const m = matrix.length, n = matrix[0].length
  let flag = false // 第一列是否有 0
  for (let i = 0; i < m; i++) {
    if (matrix[i][0] === 0) flag = true
    for (let j = 1; j < n; j++) {
      if (matrix[i][j] === 0) {
        matrix[i][0] = matrix[0][j] = 0
      }
    }
  }
  for (let i = m - 1; i >= 0; i--) {
    for (let j = 1; j < n; j++) {
      if (matrix[i][0] === 0 || matrix[0][j] === 0) {
        matrix[i][j] = 0
      }
    }
    if (flag) matrix[i][0] = 0
  }
}
```

